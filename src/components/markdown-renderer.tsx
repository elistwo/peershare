"use client";

import React from 'react';
import ReactMarkdown from 'react-markdown';
import rehypeRaw from 'rehype-raw';
import remarkGfm from 'remark-gfm';
import { CodeBlock } from './code-block';

export interface MarkdownRendererProps {
  content: string;
}

export const MarkdownRenderer = ({ content }: MarkdownRendererProps) => {
  return (
    <div className="prose dark:prose-invert max-w-none">
      <ReactMarkdown
        rehypePlugins={[rehypeRaw]}
        remarkPlugins={[remarkGfm]}
        components={{
          pre({ node, children, ...props }) {
            // The `pre` element generated by react-markdown has a single `code` child.
            // We want to pass its props to our CodeBlock.
            const codeChild = React.Children.toArray(children)[0] as React.ReactElement<{ className?: string, children: React.ReactNode }>;
            
            if (codeChild && codeChild.props) {
              const languageMatch = /language-(\w+)/.exec(codeChild.props.className || '');
              return (
                <CodeBlock language={languageMatch ? languageMatch[1] : ''}>
                  {String(codeChild.props.children).replace(/\n$/, '')}
                </CodeBlock>
              );
            }
            // Fallback for any other case, though unlikely with standard markdown.
            return <pre {...props}>{children}</pre>;
          },
          code({ node, className, children, ...props }) {
            // This will only render for inline code, as code within `pre` is handled above.
            return (
              <code className={className} {...props}>
                {children}
              </code>
            );
          },
        }}
      >
        {content}
      </ReactMarkdown>
    </div>
  );
};
